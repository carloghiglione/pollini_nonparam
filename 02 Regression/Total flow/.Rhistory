set.seed(1)
data.fr <- data.frame(log_flow=log_flow, uni_score = uni_score)
kfolds <- quantile_kfold(n_fold, data.fr, 'uni_score')
# function to find RMSE for a certain bandwidth
find.RMSE <- function(curr.knots, n_fold, kfolds){
require(np)
RMSE <- numeric(n_fold)
for(i in 1:n_fold){
curr_data <- kfolds$datasets[[i]]
curr_miss <- kfolds$folds[[i]]
int.knots <- quantile(curr_data$uni_score, seq(0, 1, length.out=curr.knots+2))[3:(curr.knots)]
ext.knots <- quantile(curr_data$uni_score, seq(0, 1, length.out=curr.knots+2))[c(2, curr.knots+1)]
mod.curr <- lm(log_flow ~ ns(uni_score, knots = int.knots, Boundary.knots = ext.knots), data = curr_data)
RMSE[i] <- sqrt(mean((predict(mod.curr, newdata=curr_miss) - curr_miss$log_flow)^2))
}
return(mean(RMSE))
}
# set the grid of dof search
knots.grid <- seq(3, 20, by=1)
# define cores for parallel computation
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE", "kfolds", "ns"))
RMSE_wrapper <- function(curr.knots){find.RMSE(curr.knots, n_fold, kfolds)}
# find RMSE for all grid points with parallel computing
all_RMSE <- pbsapply(knots.grid, RMSE_wrapper, cl=cl)
# optimal number of neighbors, span and corresponding RMSE
opt.knots <- knots.grid[which.min(all_RMSE)]
opt.knots
min(all_RMSE)
x11()
plot(knots.grid, all_RMSE, type ='l', lwd='2', main='Root MSE vs span')
abline(v=opt.knots, col='red', lwd=2)
#######################################################################################
# NATURAL CUBIC B-SPLINES WITH OPTIMAL DOF
int.knots <- quantile(uni_score, seq(0, 1, length.out=opt.knots+2))[3:(opt.knots)]
ext.knots <- quantile(uni_score, seq(0, 1, length.out=opt.knots+2))[c(2, opt.knots+1)]
mod.nat.3.opt <- lm(log_flow ~ ns(uni_score, knots = int.knots, Boundary.knots = ext.knots))
summary(mod.nat.3.opt)
x11()
par(mfrow=c(2,2))
plot(mod.nat.3.opt)
shapiro.test(mod.nat.3.opt$residuals)
# I plot fitted values +- 2 * standard errors)
xx <- seq(min(uni_score), max(uni_score), length.out = 1000)
preds <- predict(mod.nat.3.opt, data.frame(uni_score = xx), se.fit=T)
x11()
plot(uni_score, log_flow, main = 'Natural Cubic splines')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
abline(v=c(int.knots, ext.knots), lty=2, col='gray')
RMSE <- sqrt(mean((mod.nat.3.opt$residuals)^2))
RMSE
rm(list=ls())
library(car)
library(ISLR2)
library(np)
library(splines)
library(fda)
library(pbapply)
library(parallel)
full_tab <- read.csv('full_tab_31_10_21.csv')
##################
# creo tabelle con variabili di interesse
log_flow <- log(full_tab$tot_in + full_tab$tot_out)    # in + out
uni_score <- full_tab$uni_score
countries <- full_tab$Country
###############################################################
# SMOOTHING CUBIC B-SPLINES
# SELECT OPTIMAL LAMBDA WITH CROSS-VALIDATION
fit.s.spline.loocv <- smooth.spline(uni_score, log_flow, cv=T)
fit.s.spline.gcv <- smooth.spline(uni_score, log_flow, cv=F)
x11()
plot(uni_score, log_flow, main = 'Smoothing cubic splines')
lines(fit.s.spline.loocv, col='red', lwd=2)
#lines(fit.s.spline.gcv, col='blue', lwd=2)
legend('bottomright', legend = c('LOOCV', 'GCV'), fill = c('red', 'blue'))
############################################################################################
# I find RMSE and optimal span with CROSS-VALIDATION
source('quantile_kfold.R')
# define the folds
n_fold <- 5
set.seed(1)
data.fr <- data.frame(log_flow=log_flow, uni_score = uni_score)
kfolds <- quantile_kfold(n_fold, data.fr, 'uni_score')
# function to find RMSE for a certain bandwidth
find.RMSE <- function(curr.lam, n_fold, kfolds){
require(np)
RMSE <- numeric(n_fold)
for(i in 1:n_fold){
curr_data <- kfolds$datasets[[i]]
curr_miss <- kfolds$folds[[i]]
mod.curr <- smooth.spline(curr_data$uni_score, curr_data$log_flow, lambda = curr.lam)
RMSE[i] <- sqrt(mean((predict(mod.curr, curr_miss$uni_score)$y - curr_miss$log_flow)^2))
}
return(mean(RMSE))
}
# set the grid of dof search
lam.grid <- seq(1e-7, 1e-3, by=1e-7)
# define cores for parallel computation
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE", "kfolds", "smooth.spline"))
RMSE_wrapper <- function(curr.lam){find.RMSE(curr.lam, n_fold, kfolds)}
# find RMSE for all grid points with parallel computing
all_RMSE <- pbsapply(lam.grid, RMSE_wrapper, cl=cl)
# optimal number of neighbors, span and corresponding RMSE
opt.lam <- lam.grid[which.min(all_RMSE)]
opt.lam
min(all_RMSE)
x11()
plot(lam.grid, all_RMSE, type ='l', lwd='2', main='Root MSE vs span')
abline(v=opt.lam, col='red', lwd=2)
#######################################################################################
# SMOOTHING CUBIC B-SPLINES WITH OPTIMAAL LAMBDA
fit.smooth.opt <- smooth.spline(uni_score, log_flow, lambda = opt.lam)
x11()
plot(uni_score, log_flow, main = 'Smoothing cubic splines')
lines(fit.smooth.opt, col='red', lwd=2)
points(fit.smooth.opt$x, fit.smooth.opt$y, pch='x')
RMSE <- sqrt(mean((predict(fit.smooth.opt, uni_score)$y- log_flow)^2))
RMSE
x11()
plot(uni_score, log_flow, main = 'Smoothing cubic splines')
lines(fit.smooth.opt, col='red', lwd=2)
points(fit.smooth.opt$x, fit.smooth.opt$y, pch='x', col='blue')
rm(list=ls())
library(car)
library(ISLR2)
library(np)
library(splines)
library(fda)
library(pbapply)
library(parallel)
full_tab <- read.csv('full_tab_31_10_21.csv')
##################
# creo tabelle con variabili di interesse
log_flow <- log(full_tab$tot_in + full_tab$tot_out)    # in + out
uni_score <- full_tab$uni_score
countries <- full_tab$Country
############################################################################################
# I find RMSE and optimal span with CROSS-VALIDATION
source('quantile_kfold.R')
# define the folds
n_fold <- 5
set.seed(1)
data.fr <- data.frame(log_flow=log_flow, uni_score = uni_score)
kfolds <- quantile_kfold(n_fold, data.fr, 'uni_score')
# function to find RMSE for a certain bandwidth
find.RMSE.knn <- function(curr.bws, n_fold, kfolds){
require(np)
RMSE <- numeric(n_fold)
for(i in 1:n_fold){
curr_data <- kfolds$datasets[[i]]
curr_miss <- kfolds$folds[[i]]
mod.curr <- npreg(log_flow ~ uni_score, bwtype='adaptive_nn', ckertype = 'gaussian', bws=curr.bws, data = curr_data)
RMSE[i] <- sqrt(mean((predict(mod.curr, newdata=curr_miss) - curr_miss$log_flow)^2))
}
return(mean(RMSE))
}
# set the grid of nearest neighbors search
neigh.grid <- seq(1, ceiling(n/2), by=1)
span.grid <- neigh.grid/n
# define cores for parallel computation
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE.knn", "kfolds"))
RMSE_wrapper <- function(curr.bws){find.RMSE.knn(curr.bws, n_fold, kfolds)}
# find RMSE for all grid points with parallel computing
all_RMSE <- pbsapply(neigh.grid, RMSE_wrapper, cl=cl)
# optimal number of neighbors, span and corresponding RMSE
opt.neigh <- neigh.grid[which.min(all_RMSE)]
opt.neigh
opt.span <- opt.neigh/n
opt.span
min(all_RMSE)
x11()
plot(span.grid, all_RMSE, type ='l', lwd='2', main='Root MSE vs span')
abline(v=opt.span, col='red', lwd=2)
setwd("C:/Users/carlo/Desktop/Progetto_nonparam/02 Regression/Total flow")
rm(list=ls())
library(car)
library(ISLR2)
library(np)
library(splines)
library(fda)
library(pbapply)
library(parallel)
full_tab <- read.csv('full_tab_31_10_21.csv')
##################
# creo tabelle con variabili di interesse
log_flow <- log(full_tab$tot_in + full_tab$tot_out)    # in + out
uni_score <- full_tab$uni_score
countries <- full_tab$Country
############################################################################################
# I find RMSE and optimal span with CROSS-VALIDATION
source('quantile_kfold.R')
# define the folds
n_fold <- 5
set.seed(1)
data.fr <- data.frame(log_flow=log_flow, uni_score = uni_score)
kfolds <- quantile_kfold(n_fold, data.fr, 'uni_score')
# function to find RMSE for a certain bandwidth
find.RMSE.knn <- function(curr.bws, n_fold, kfolds){
require(np)
RMSE <- numeric(n_fold)
for(i in 1:n_fold){
curr_data <- kfolds$datasets[[i]]
curr_miss <- kfolds$folds[[i]]
mod.curr <- npreg(log_flow ~ uni_score, bwtype='adaptive_nn', ckertype = 'gaussian', bws=curr.bws, data = curr_data)
RMSE[i] <- sqrt(mean((predict(mod.curr, newdata=curr_miss) - curr_miss$log_flow)^2))
}
return(mean(RMSE))
}
# set the grid of nearest neighbors search
neigh.grid <- seq(1, ceiling(n/2), by=1)
span.grid <- neigh.grid/n
# define cores for parallel computation
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE.knn", "kfolds"))
RMSE_wrapper <- function(curr.bws){find.RMSE.knn(curr.bws, n_fold, kfolds)}
# find RMSE for all grid points with parallel computing
all_RMSE <- pbsapply(neigh.grid, RMSE_wrapper, cl=cl)
# optimal number of neighbors, span and corresponding RMSE
opt.neigh <- neigh.grid[which.min(all_RMSE)]
opt.neigh
opt.span <- opt.neigh/n
opt.span
min(all_RMSE)
x11()
plot(span.grid, all_RMSE, type ='l', lwd='2', main='Root MSE vs span')
abline(v=opt.span, col='red', lwd=2)
# set the grid of nearest neighbors search
neigh.grid <- seq(1, ceiling(n/2), by=1)
##################################################################################
# MIXED GAUSSIAN KERNEL & KNN LOCAL LINEAR REGRESSION
# NUMBER OF NEIGHBORS SELECTION WITH CROSS-VALIDATION ON LS
# direcly select number of neighbors
k <- 5
# select span
n <- length(log_flow)
span <- 0.05
k <- as.integer(span*n)
mod.knn <- npreg(log_flow ~ uni_score, bwtype='adaptive_nn', bwmethod="cv.ls", ckertype = 'gaussian')
summary(mod.knn)
xx <- seq(min(uni_score), max(uni_score), length.out = 1000)
preds <- predict(mod.knn, newdata = data.frame(uni_score = xx), se.fit=T)
x11()
plot(uni_score, log_flow, main = 'KNN regression')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
# number of neighbors
mod.knn$bw
# RMSE
sqrt(mod.knn$MSE)
############################################################################################
# I find RMSE and optimal span with CROSS-VALIDATION
source('quantile_kfold.R')
# define the folds
n_fold <- 5
set.seed(1)
data.fr <- data.frame(log_flow=log_flow, uni_score = uni_score)
kfolds <- quantile_kfold(n_fold, data.fr, 'uni_score')
# function to find RMSE for a certain bandwidth
find.RMSE.knn <- function(curr.bws, n_fold, kfolds){
require(np)
RMSE <- numeric(n_fold)
for(i in 1:n_fold){
curr_data <- kfolds$datasets[[i]]
curr_miss <- kfolds$folds[[i]]
mod.curr <- npreg(log_flow ~ uni_score, bwtype='adaptive_nn', ckertype = 'gaussian', bws=curr.bws, data = curr_data)
RMSE[i] <- sqrt(mean((predict(mod.curr, newdata=curr_miss) - curr_miss$log_flow)^2))
}
return(mean(RMSE))
}
# set the grid of nearest neighbors search
neigh.grid <- seq(1, ceiling(n/2), by=1)
span.grid <- neigh.grid/n
# define cores for parallel computation
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE.knn", "kfolds"))
RMSE_wrapper <- function(curr.bws){find.RMSE.knn(curr.bws, n_fold, kfolds)}
# find RMSE for all grid points with parallel computing
all_RMSE <- pbsapply(neigh.grid, RMSE_wrapper, cl=cl)
# optimal number of neighbors, span and corresponding RMSE
opt.neigh <- neigh.grid[which.min(all_RMSE)]
opt.neigh
opt.span <- opt.neigh/n
opt.span
min(all_RMSE)
x11()
plot(span.grid, all_RMSE, type ='l', lwd='2', main='Root MSE vs span')
abline(v=opt.span, col='red', lwd=2)
#########################################################################################
# MIXED GAUSSIAN KERNEL & KNN LOCAL LINEAR REGRESSION WITH OPTIMAL NUMBER OF NEIGHBORS
mod.knn.opt <- npreg(log_flow ~ uni_score, ckertype = 'gaussian', bws=opt.neigh, bwtype='adaptive_nn')
summary(mod.knn)
xx <- seq(min(uni_score), max(uni_score), length.out = 1000)
preds <- predict(mod.knn.opt, newdata = data.frame(uni_score = xx), se.fit=T)
x11()
plot(uni_score, log_flow, main = 'Gaussian kernel regression')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
# RMSE
sqrt(mod.knn.opt$MSE)
rm(list=ls())
library(car)
library(ISLR2)
library(np)
library(splines)
library(fda)
library(pbapply)
library(parallel)
full_tab <- read.csv('full_tab_31_10_21.csv')
##################
# creo tabelle con variabili di interesse
log_flow <- log(full_tab$tot_in + full_tab$tot_out)    # in + out
uni_score <- full_tab$uni_score
countries <- full_tab$Country
#######################################################################################
# NATURAL CUBIC B-SPLINES
# SET KNOTS ACCORDING TO EVENLY SPACED QUANTILES
# number of knots
n_knots <- 5
int.knots <- quantile(uni_score, seq(0, 1, length.out=n_knots+2))[3:(n_knots)]
ext.knots <- quantile(uni_score, seq(0, 1, length.out=n_knots+2))[c(2, n_knots+1)]
mod.nat.spline.3 <- lm(log_flow ~ ns(uni_score, knots = int.knots, Boundary.knots = ext.knots))
summary(mod.nat.spline.3)
x11()
par(mfrow=c(2,2))
plot(mod.nat.spline.3)
shapiro.test(mod.nat.spline.3$residuals)
# I plot fitted values +- 2 * standard errors)
xx <- seq(min(uni_score), max(uni_score), length.out = 1000)
preds <- predict(mod.nat.spline.3, data.frame(uni_score = xx), se.fit=T)
x11()
plot(uni_score, log_flow, main = 'Natural Cubic splines')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
abline(v=c(int.knots, ext.knots), lty=2, col='gray')
############################################################################################
# I find RMSE and optimal span with CROSS-VALIDATION
source('quantile_kfold.R')
# define the folds
n_fold <- 5
set.seed(1)
data.fr <- data.frame(log_flow=log_flow, uni_score = uni_score)
kfolds <- quantile_kfold(n_fold, data.fr, 'uni_score')
# function to find RMSE for a certain bandwidth
find.RMSE <- function(curr.knots, n_fold, kfolds){
require(np)
RMSE <- numeric(n_fold)
for(i in 1:n_fold){
curr_data <- kfolds$datasets[[i]]
curr_miss <- kfolds$folds[[i]]
int.knots <- quantile(curr_data$uni_score, seq(0, 1, length.out=curr.knots+2))[3:(curr.knots)]
ext.knots <- quantile(curr_data$uni_score, seq(0, 1, length.out=curr.knots+2))[c(2, curr.knots+1)]
mod.curr <- lm(log_flow ~ ns(uni_score, knots = int.knots, Boundary.knots = ext.knots), data = curr_data)
RMSE[i] <- sqrt(mean((predict(mod.curr, newdata=curr_miss) - curr_miss$log_flow)^2))
}
return(mean(RMSE))
}
# set the grid of dof search
knots.grid <- seq(3, 20, by=1)
# define cores for parallel computation
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE", "kfolds", "ns"))
RMSE_wrapper <- function(curr.knots){find.RMSE(curr.knots, n_fold, kfolds)}
# find RMSE for all grid points with parallel computing
all_RMSE <- pbsapply(knots.grid, RMSE_wrapper, cl=cl)
# optimal number of neighbors, span and corresponding RMSE
opt.knots <- knots.grid[which.min(all_RMSE)]
opt.knots
min(all_RMSE)
x11()
plot(knots.grid, all_RMSE, type ='l', lwd='2', main='Root MSE vs span')
abline(v=opt.knots, col='red', lwd=2)
#######################################################################################
# NATURAL CUBIC B-SPLINES WITH OPTIMAL DOF
int.knots <- quantile(uni_score, seq(0, 1, length.out=opt.knots+2))[3:(opt.knots)]
ext.knots <- quantile(uni_score, seq(0, 1, length.out=opt.knots+2))[c(2, opt.knots+1)]
mod.nat.3.opt <- lm(log_flow ~ ns(uni_score, knots = int.knots, Boundary.knots = ext.knots))
summary(mod.nat.3.opt)
x11()
par(mfrow=c(2,2))
plot(mod.nat.3.opt)
shapiro.test(mod.nat.3.opt$residuals)
# I plot fitted values +- 2 * standard errors)
xx <- seq(min(uni_score), max(uni_score), length.out = 1000)
preds <- predict(mod.nat.3.opt, data.frame(uni_score = xx), se.fit=T)
x11()
plot(uni_score, log_flow, main = 'Natural Cubic splines')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
abline(v=c(int.knots, ext.knots), lty=2, col='gray')
RMSE <- sqrt(mean((mod.nat.3.opt$residuals)^2))
RMSE
#====
#importing the needed libraries
library(ISLR2)
library(car)
library(mgcv)
library(rgl)
library(splines)
library(pbapply)
full_tab_31_10_21 <- read.csv("C:/Users/user/Desktop/Pollini in fuga/Pollini_nonparam/pollini_nonparam/00 Tabelle importanti/full_tab_31_10_21.csv")
View(full_tab_31_10_21)
#importing data
data <- full_tab_31_10_21
pat <- data$Patent.applications..nonresidents + data$Patent.applications..residents #we consider the total number of patents deposited in a country, ignoring if they were deposited by residents or nonresidents in said country
#First attempt: a nonparametric model using as regressor the one that our groupwise linear model was based on
g <- gam(data$tot_in + data$tot_out ~ s(data$uni_score, bs='cr'))
summary(g)
x11()
plot(g)
#___________________________________________________________________________________
#so we confirm our initial choice for a model
gmod <- gam(log(data$tot_in + data$tot_out) ~ s(data$uni_score, bs='cr'))
summary(gmod)
plot(gmod)
x11()
plot(gmod)
#We start by looking for a simple linear regression in terms of education related parameters
#it should be noted that during the Applied Statistics project, the best linear model for uni_score was based on patents, GDP and GDP^2
#Now we are also considering now topic-related variables
us <- lm(data$uni_score ~ data$Citations.per.document + data$num_staff + data$stud_per_staff + data$Reasearch + pat + data$GDP + I(data$GDP^2))
summary(us)
shapiro.test(us$residuals)
summary(us6)
#reduced model: eliminate research
us6 <- lm(data$uni_score ~ data$Citations.per.document + pat)
summary(us6)
#reduced model: remove gdp^2
us5 <- lm(data$uni_score ~ data$Citations.per.document + data$Reasearch + pat)
summary(us5)
plot(data$Citations.per.document, data$uni_score)
plot(log(pat), logus)
logus <- log(data$uni_score + 1)
#we can however try to do better
logus <- log(data$uni_score + 1)
plot(log(pat), logus)
lus <- lm(logus ~ log(pat))
summary(logus)
summary(lus)
shapiro.test(lus$residuals)
qqnorm(lus$residuals)
qqline(lus$residuals)
lus <- lm(logus ~ I(log(pat)))
summary(lus)
lus <- lm(logus ~ log(pat))
summary(lus)
lus_pot <- lm(logus ~ log(pat) + log(data$Citations.per.document))
summary(lus_pot)
shapiro.test(lus_pot$residuals)
qqnorm(lus_pot$residuals)
qqline(lus_pot$residuals)
Citations.per.document
data$Citations.per.document
#We are looking for a clustering structure among our countries based on the difference in mobility
#Each country is represented in R2 by (total number of people going in, total number of people going out) during our time horizon
#we first of all build the distance matrix (Euclidian distance)
diss <- dist(Trips_ext$tot_in, Trips_ext$tot_out, method = 'euclidian')
Trips_ext <- read.csv("C:/Users/user/Desktop/Pollini in fuga/Pollini_nonparam/pollini_nonparam/00 Tabelle importanti/Trips_ext.CSV", sep=";")
View(Trips_ext)
#We are looking for a clustering structure among our countries based on the difference in mobility
#Each country is represented in R2 by (total number of people going in, total number of people going out) during our time horizon
#we first of all build the distance matrix (Euclidian distance)
diss <- dist(Trips_ext$tot_in, Trips_ext$tot_out, method = 'euclidian')
#Ward is the only clustering structure that does not just separate UK from the rest of Europe
clus <- hclust(diss, method = 'ward.D2')
plot(clus)
#Ward is the only clustering structure that does not just separate UK from the rest of Europe
clus <- hclust(diss, method = 'ward.D2')
x11()
plot(clus)
x11()
plot(Trips_ext$tot_in, Trips_ext$tot_out, main = "Clustering structure", xlab = "Ingoing flow", ylab = "Outgoing flow")
points(Trips_ext$tot_in[which(lab == "1")], Trips_ext$tot_out[which(lab == "1")], col = 'green')
points(Trips_ext$tot_in[which(lab == "2")], Trips_ext$tot_out[which(lab == "2")], col = 'red')
legend(fill = c('green', 'red'),legend = c("First cluster", "Second cluster"), "topleft")
x11()
plot(log(Trips_ext$tot_in), log(Trips_ext$tot_out), main = "Clustering structure", xlab = "Ingoing flow", ylab = "Outgoing flow")
points(log(Trips_ext$tot_in[which(lab == "1")]), log(Trips_ext$tot_out[which(lab == "1")]), col = 'green')
points(log(Trips_ext$tot_in[which(lab == "2")]), log(Trips_ext$tot_out[which(lab == "2")]), col = 'red')
legend(fill = c('green', 'red'),legend = c("First cluster", "Second cluster"), "topleft")
lab <- cutree(clus, 2)
flowlab <- cbind(Country = Trips_ext$Country, label = lab)
flowlab
Trips_ext$Country[which(lab == "2")]
plot(Trips_ext$tot_in, Trips_ext$tot_out, main = "Clustering structure", xlab = "Ingoing flow", ylab = "Outgoing flow")
points(Trips_ext$tot_in[which(lab == "1")], Trips_ext$tot_out[which(lab == "1")], col = 'green')
points(Trips_ext$tot_in[which(lab == "2")], Trips_ext$tot_out[which(lab == "2")], col = 'red')
legend(fill = c('green', 'red'),legend = c("First cluster", "Second cluster"), "topleft")
x11()
plot(Trips_ext$tot_in, Trips_ext$tot_out, main = "Clustering structure", xlab = "Ingoing flow", ylab = "Outgoing flow")
points(Trips_ext$tot_in[which(lab == "1")], Trips_ext$tot_out[which(lab == "1")], col = 'green')
points(Trips_ext$tot_in[which(lab == "2")], Trips_ext$tot_out[which(lab == "2")], col = 'red')
legend(fill = c('green', 'red'),legend = c("First cluster", "Second cluster"), "topleft")
x11()
plot(log(Trips_ext$tot_in), log(Trips_ext$tot_out), main = "Clustering structure", xlab = "Ingoing flow", ylab = "Outgoing flow")
points(log(Trips_ext$tot_in[which(lab == "1")]), log(Trips_ext$tot_out[which(lab == "1")]), col = 'green')
points(log(Trips_ext$tot_in[which(lab == "2")]), log(Trips_ext$tot_out[which(lab == "2")]), col = 'red')
legend(fill = c('green', 'red'),legend = c("First cluster", "Second cluster"), "topleft")
x11()
plot(log(Trips_ext$tot_in), log(Trips_ext$tot_out), main = "Clustering structure", xlab = "Ingoing_flow_logscale", ylab = "Outgoing_flow_logscale")
points(log(Trips_ext$tot_in[which(lab == "1")]), log(Trips_ext$tot_out[which(lab == "1")]), col = 'green')
points(log(Trips_ext$tot_in[which(lab == "2")]), log(Trips_ext$tot_out[which(lab == "2")]), col = 'red')
legend(fill = c('green', 'red'),legend = c("First cluster", "Second cluster"), "topleft")
x11()
plot(clus)
