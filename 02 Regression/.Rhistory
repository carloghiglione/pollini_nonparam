RMSE_wrapper <- function(curr.bws){find.RMSE(curr.bws, n_fold, kfolds)}
all_RMSE <- pbsapply(bws.grid, RMSE_wrapper, cl=cl)
opt.bws <- bws.grid[which.min(RMSE)]
opt.bws
min(RMSE)
x11()
plot(bws.grid, all_RMSE, type ='l', lwd='2', main='Root MSE vs bandwidth')
abline(v=opt.bws, col='red', lwd=2)
mod.ker.opt <- npreg(flow.norm ~ scores.pc1, ckertype = 'gaussian', bws=opt.bws)
summary(mod.ker)
xx <- seq(min(scores.pc1), max(scores.pc1), length.out = 1000)
preds <- predict(mod.ker.opt, newdata = data.frame(scores.pc1 = xx), se.fit=T)
x11()
plot(scores.pc1, flow.norm, main = 'Gaussian kernel regression')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
min(RMSE)
# set the grid of bandwidth for search
bws.grid <- seq(0.2, 2.5, by=0.01)
RMSE <- numeric(length(bws.grid))
library(pbapply)
library(parallel)
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE", "kfolds"))
RMSE_wrapper <- function(curr.bws){find.RMSE(curr.bws, n_fold, kfolds)}
all_RMSE <- pbsapply(bws.grid, RMSE_wrapper, cl=cl)
opt.bws <- bws.grid[which.min(RMSE)]
opt.bws
min(RMSE)
x11()
plot(bws.grid, all_RMSE, type ='l', lwd='2', main='Root MSE vs bandwidth')
abline(v=opt.bws, col='red', lwd=2)
mod.ker.opt <- npreg(flow.norm ~ scores.pc1, ckertype = 'gaussian', bws=opt.bws)
summary(mod.ker)
xx <- seq(min(scores.pc1), max(scores.pc1), length.out = 1000)
preds <- predict(mod.ker.opt, newdata = data.frame(scores.pc1 = xx), se.fit=T)
x11()
plot(scores.pc1, flow.norm, main = 'Gaussian kernel regression')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
# set the grid of bandwidth for search
bws.grid <- seq(0.25, 2.5, by=0.01)
RMSE <- numeric(length(bws.grid))
library(pbapply)
library(parallel)
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE", "kfolds"))
RMSE_wrapper <- function(curr.bws){find.RMSE(curr.bws, n_fold, kfolds)}
all_RMSE <- pbsapply(bws.grid, RMSE_wrapper, cl=cl)
opt.bws <- bws.grid[which.min(RMSE)]
opt.bws
min(RMSE)
x11()
plot(bws.grid, all_RMSE, type ='l', lwd='2', main='Root MSE vs bandwidth')
abline(v=opt.bws, col='red', lwd=2)
mod.ker.opt <- npreg(flow.norm ~ scores.pc1, ckertype = 'gaussian', bws=opt.bws)
summary(mod.ker)
xx <- seq(min(scores.pc1), max(scores.pc1), length.out = 1000)
preds <- predict(mod.ker.opt, newdata = data.frame(scores.pc1 = xx), se.fit=T)
x11()
plot(scores.pc1, flow.norm, main = 'Gaussian kernel regression')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
rm(list=ls())
library(car)
library(ISLR2)
library(np)
library(splines)
library(fda)
#################
# load data
full_tab <- read.csv('full_tab_31_10_21.csv')
flow <- full_tab$tot_in - full_tab$tot_out    # in - out
flow.norm <- flow / full_tab$num_ric
countries <- full_tab$Country
Z <- data.frame(flow.norm, full_tab[, c(4,6,8,17)])
x11()
pairs(Z)
##################################################################
# do PCA on the regressors
tab <- Z[,-1]
# standardized data
tab.std <- data.frame(scale(tab))
# PCA
pca.std <- princomp(tab.std, scores = T)
print(summary(pca.std))
# collect scores of first PCA
scores.pc1  <- pca.std$scores[,1]
# remove NA (identified previous script)
flow.norm[4] <- NA    # tolgo Cipro
flow.norm[19] <- NA    # tolgo Lussemburgo
flow.norm <- flow.norm[-c(4,19)]
scores.pc1 <- scores.pc1[-c(4,19)]
##################################################################################
# KERNEL LOCAL AVERAGING REGRESSION
# BANDWIDTH SELECTION WITH CROSS-VALIDATION ON LS
mod.ker <- npreg(flow.norm ~ scores.pc1, ckertype = 'gaussian', bwmethod="cv.ls")
summary(mod.ker)
xx <- seq(min(scores.pc1), max(scores.pc1), length.out = 1000)
preds <- predict(mod.ker, newdata = data.frame(scores.pc1 = xx), se.fit=T)
x11()
plot(scores.pc1, flow.norm, main = 'Gaussian kernel regression')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
# bandwidth
mod.ker$bw
########################
# I find RMSE with CROSS-VALIDATION
source('quantile_kfold.R')
n_fold <- 5
set.seed(1)
data.fr <- data.frame(flow.norm=flow.norm, scores.pc1 = scores.pc1)
kfolds <- quantile_kfold(n_fold, data.fr, 'scores.pc1')
# function to find RMSE for a certain bandwidth
find.RMSE <- function(curr.bws, n_fold, kfolds){
require(np)
RMSE <- numeric(n_fold)
for(i in 1:n_fold){
curr_data <- kfolds$datasets[[i]]
curr_miss <- kfolds$folds[[i]]
mod.curr <- npreg(flow.norm ~ scores.pc1, ckertype = 'gaussian', bws=curr.bws, data = curr_data)
RMSE[i] <- sqrt(mean((predict(mod.curr, newdata=curr_miss) - curr_miss$flow.norm)^2))
}
return(mean(RMSE))
}
# set the grid of bandwidth for search
bws.grid <- seq(0.1, 2.5, by=0.01)
library(pbapply)
library(parallel)
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE", "kfolds"))
RMSE_wrapper <- function(curr.bws){find.RMSE(curr.bws, n_fold, kfolds)}
all_RMSE <- pbsapply(bws.grid, RMSE_wrapper, cl=cl)
opt.bws <- bws.grid[which.min(all_RMSE)]
opt.bws
min(all_RMSE)
x11()
plot(bws.grid, all_RMSE, type ='l', lwd='2', main='Root MSE vs bandwidth')
abline(v=opt.bws, col='red', lwd=2)
mod.ker.opt <- npreg(flow.norm ~ scores.pc1, ckertype = 'gaussian', bws=opt.bws)
summary(mod.ker)
xx <- seq(min(scores.pc1), max(scores.pc1), length.out = 1000)
preds <- predict(mod.ker.opt, newdata = data.frame(scores.pc1 = xx), se.fit=T)
x11()
plot(scores.pc1, flow.norm, main = 'Gaussian kernel regression')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
# direcly select number of neighbors
k <- 5
# select span
n <- sum(!is.na(flow.norm))
span <- 0.05
k <- as.integer(span*n)
mod.knn <- npreg(flow.norm ~ scores.pc1, bwtype='adaptive_nn', bwmethod="cv.ls", ckertype = 'gaussian')
summary(mod.knn)
xx <- seq(min(scores.pc1), max(scores.pc1), length.out = 1000)
preds <- predict(mod.knn, newdata = data.frame(scores.pc1 = xx), se.fit=T)
x11()
plot(scores.pc1, flow.norm, main = 'KNN regression')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
# number of neighbors
mod.knn$bw
# MSE
mod.knn$MSE
# RMSE
sqrt(mod.knn$MSE)
# function to find RMSE for a certain bandwidth
find.RMSE.ker <- function(curr.bws, n_fold, kfolds){
require(np)
RMSE <- numeric(n_fold)
for(i in 1:n_fold){
curr_data <- kfolds$datasets[[i]]
curr_miss <- kfolds$folds[[i]]
mod.curr <- npreg(flow.norm ~ scores.pc1, ckertype = 'gaussian', bws=curr.bws, data = curr_data)
RMSE[i] <- sqrt(mean((predict(mod.curr, newdata=curr_miss) - curr_miss$flow.norm)^2))
}
return(mean(RMSE))
}
# set the grid of bandwidth for search
bws.grid <- seq(0.1, 2.5, by=0.01)
library(pbapply)
library(parallel)
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE.ker", "kfolds"))
RMSE_wrapper <- function(curr.bws){find.RMSE.ker(curr.bws, n_fold, kfolds)}
all_RMSE <- pbsapply(bws.grid, RMSE_wrapper, cl=cl)
opt.bws <- bws.grid[which.min(all_RMSE)]
opt.bws
min(all_RMSE)
# set the grid of nearest neighobrsfor search
bws.grid <- seq(1, 15, by=1)
# set the grid of nearest neighobrsfor search
bws.grid <- seq(1, 15, by=1)
library(pbapply)
library(parallel)
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE.knn", "kfolds"))
RMSE_wrapper <- function(curr.bws){find.RMSE.knn(curr.bws, n_fold, kfolds)}
all_RMSE <- pbsapply(bws.grid, RMSE_wrapper, cl=cl)
opt.bws <- bws.grid[which.min(all_RMSE)]
opt.bws
min(all_RMSE)
# function to find RMSE for a certain bandwidth
find.RMSE.knn <- function(curr.bws, n_fold, kfolds){
require(np)
RMSE <- numeric(n_fold)
for(i in 1:n_fold){
curr_data <- kfolds$datasets[[i]]
curr_miss <- kfolds$folds[[i]]
mod.curr <- npreg(flow.norm ~ scores.pc1, bwtype='adaptive_nn', ckertype = 'gaussian', bws=curr.bws, data = curr_data)
RMSE[i] <- sqrt(mean((predict(mod.curr, newdata=curr_miss) - curr_miss$flow.norm)^2))
}
return(mean(RMSE))
}
# set the grid of nearest neighobrsfor search
bws.grid <- seq(1, 15, by=1)
library(pbapply)
library(parallel)
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE.knn", "kfolds"))
RMSE_wrapper <- function(curr.bws){find.RMSE.knn(curr.bws, n_fold, kfolds)}
all_RMSE <- pbsapply(bws.grid, RMSE_wrapper, cl=cl)
opt.bws <- bws.grid[which.min(all_RMSE)]
opt.bws
min(all_RMSE)
x11()
plot(bws.grid, all_RMSE, type ='l', lwd='2', main='Root MSE vs bandwidth')
abline(v=opt.bws, col='red', lwd=2)
mod.knn.opt <- npreg(flow.norm ~ scores.pc1, ckertype = 'gaussian', bws=opt.bws, bwtype='adaptive_nn')
summary(mod.knn)
xx <- seq(min(scores.pc1), max(scores.pc1), length.out = 1000)
preds <- predict(mod.knn.opt, newdata = data.frame(scores.pc1 = xx), se.fit=T)
x11()
plot(scores.pc1, flow.norm, main = 'Gaussian kernel regression')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
sqrt(mod.ker.opt$MSE)
rm(list=ls())
library(car)
full_tab <- read.csv('full_tab_31_10_21.csv')
##################
# creo tabelle con variabili di interesse
flow <- full_tab$tot_in - full_tab$tot_out    # in - out
flow.norm <- flow / full_tab$num_ric
#Z <- data.frame(flow, full_tab[, c(4,6,8,17)])
Z <- data.frame(flow.norm, full_tab[, c(4,6,8,17)])
countries <- full_tab$Country
##################
# visualize results
x11()
pairs(Z)
##########################################################################################
# perform PCA on the regressors
tab <- Z[,-1]
x11()
par(mfrow=c(1,2))
boxplot(scale(tab, center = T, scale = F), main='Boxplot of original data')
barplot(sapply(tab, sd)^2, las=2, main='Original Data Variables')
# very significant difference among covariates, better to normalize them
tab.std <- data.frame(scale(tab))
x11()
boxplot(tab.std, main = 'Boxplot of standardized data')
# I do PCA
pca.std<- princomp(tab.std, scores = T)
print(summary(pca.std))
# visualize PCA performances
x11()
par(mfrow=c(1,3))
boxplot(pca.std$scores, main = "Boxplot of PCA data")
barplot(pca.std$sdev^2/sum(pca.std$sdev^2), ylim = c(0,1), main = "Proportional variances of PCA data")
plot(cumsum(pca.std$sdev^2)/sum(pca.std$sdev^2), ylim = c(0,1), type = "b", main = "Cumulate variance of PCA data")
abline(h=0.8, col = 'red')
# study of loadings
load.pca.std <- pca.std$loadings[,1:4]
x11()
par(mfrow=c(1,2))
barplot(load.pca.std [,1], ylim=c(-1, 1), main = 'PC1 loadings', las=2)   #evidence on variables 1,3,4 , contrast with 2
barplot(load.pca.std [,2], ylim=c(-1, 1), main = 'PC2 loadings', las=2)   #evidence on variable 2
# collect scores of first PCA
scores.pc1  <- pca.std$scores[,1]
x11()
par(mfrow=c(1,2))
plot(scores.pc1, flow, main = "Flow vs pca")
plot(scores.pc1, flow.norm, main = "Flow norm vs pca")
###################################################################################
# LINEAR REGRESSION ON FLOW
mod <- lm(flow ~ scores.pc1)
summary(mod)
x11()
par(mfrow=c(2,2))
plot(mod)
shapiro.test(mod$residuals)
x11()
b <- mod$coefficients
xx = seq(min(scores.pc1), max(scores.pc1), length = 100)
plot(scores.pc1, flow, main = "Flow vs pca")
lines(xx, b[1] + b[2]*xx, col='red')
#################################################################################
# LINEAR REGRESSION ON NORMALIZED FLOW
# remove outliers (4 Cipro e 19 Lussemburgo)
flow.norm <- flow.norm[-c(4,19)]
scores.pc1 <- scores.pc1[-c(4,19)]
mod.norm <- lm(flow.norm ~ scores.pc1)   # è il migliore
summary(mod.norm)
x11()
par(mfrow=c(2,2))
plot(mod.norm)
shapiro.test(mod.norm$residuals)
x11()
b <- mod.norm$coefficients
xx = seq(min(scores.pc1), max(scores.pc1), length = 100)
plot(scores.pc1, flow.norm, main = "Normalized Flow vs pca")
lines(xx, b[1] + b[2]*xx, col='red')
RMSE <- sqrt(mean(mod.norm$fitted.values^2))
RMSE
rm(list=ls())
library(car)
library(ISLR2)
library(np)
library(splines)
library(fda)
library(pbapply)
library(parallel)
#################
# load data
full_tab <- read.csv('full_tab_31_10_21.csv')
flow <- full_tab$tot_in - full_tab$tot_out    # in - out
flow.norm <- flow / full_tab$num_ric
countries <- full_tab$Country
Z <- data.frame(flow.norm, full_tab[, c(4,6,8,17)])
x11()
pairs(Z)
##################################################################
# do PCA on the regressors
tab <- Z[,-1]
# standardized data
tab.std <- data.frame(scale(tab))
# PCA
pca.std <- princomp(tab.std, scores = T)
print(summary(pca.std))
# collect scores of first PCA
scores.pc1  <- pca.std$scores[,1]
# remove NA (identified previous script)
flow.norm[4] <- NA    # tolgo Cipro
flow.norm[19] <- NA    # tolgo Lussemburgo
flow.norm <- flow.norm[-c(4,19)]
scores.pc1 <- scores.pc1[-c(4,19)]
##################################################################################
# KERNEL LOCAL AVERAGING REGRESSION
mod.ker <- npreg(flow.norm ~ scores.pc1, ckertype = 'gaussian', bwmethod="cv.ls")
summary(mod.ker)
xx <- seq(min(scores.pc1), max(scores.pc1), length.out = 1000)
preds <- predict(mod.ker, newdata = data.frame(scores.pc1 = xx), se.fit=T)
x11()
plot(scores.pc1, flow.norm, main = 'Gaussian kernel regression')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
# bandwidth
mod.ker$bw
# RMSE
sqrt(mod.ker$MSE)
####################################################################################
# I find RMSE with CROSS-VALIDATION
source('quantile_kfold.R')
# define the folds
n_fold <- 5
set.seed(1)
data.fr <- data.frame(flow.norm=flow.norm, scores.pc1 = scores.pc1)
kfolds <- quantile_kfold(n_fold, data.fr, 'scores.pc1')
# function to find RMSE for a certain bandwidth
find.RMSE.ker <- function(curr.bws, n_fold, kfolds){
require(np)
RMSE <- numeric(n_fold)
for(i in 1:n_fold){
curr_data <- kfolds$datasets[[i]]
curr_miss <- kfolds$folds[[i]]
mod.curr <- npreg(flow.norm ~ scores.pc1, ckertype = 'gaussian', bws=curr.bws, data = curr_data)
RMSE[i] <- sqrt(mean((predict(mod.curr, newdata=curr_miss) - curr_miss$flow.norm)^2))
}
return(mean(RMSE))
}
# set the grid of bandwidth for search
bws.grid <- seq(0.1, 2.5, by=0.01)
# define cores for parallel computation
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE.ker", "kfolds"))
RMSE_wrapper <- function(curr.bws){find.RMSE.ker(curr.bws, n_fold, kfolds)}
# find RMSE for all grid points with parallel computing
all_RMSE <- pbsapply(bws.grid, RMSE_wrapper, cl=cl)
# optimal bandwidth and corresponding RMSE
opt.bws <- bws.grid[which.min(all_RMSE)]
opt.bws
min(all_RMSE)
x11()
plot(bws.grid, all_RMSE, type ='l', lwd='2', main='Root MSE vs bandwidth')
abline(v=opt.bws, col='red', lwd=2)
#########################################################################################
# KERNEL LOCAL AVERAGING REGRESSION WITH OPTIMAL BANDWIDTH
mod.ker.opt <- npreg(flow.norm ~ scores.pc1, ckertype = 'gaussian', bws=opt.bws)
summary(mod.ker)
xx <- seq(min(scores.pc1), max(scores.pc1), length.out = 1000)
preds <- predict(mod.ker.opt, newdata = data.frame(scores.pc1 = xx), se.fit=T)
x11()
plot(scores.pc1, flow.norm, main = 'Gaussian kernel regression')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
summary(mod.ker.opt)
# RMSE
sqrt(mod.ker.opt$MSE)
# direcly select number of neighbors
k <- 5
# select span
n <- sum(!is.na(flow.norm))
span <- 0.05
k <- as.integer(span*n)
mod.knn <- npreg(flow.norm ~ scores.pc1, bwtype='adaptive_nn', bwmethod="cv.ls", ckertype = 'gaussian')
summary(mod.knn)
xx <- seq(min(scores.pc1), max(scores.pc1), length.out = 1000)
preds <- predict(mod.knn, newdata = data.frame(scores.pc1 = xx), se.fit=T)
x11()
plot(scores.pc1, flow.norm, main = 'KNN regression')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
# number of neighbors
mod.knn$bw
# RMSE
sqrt(mod.knn$MSE)
seq(1, ceiling(n/2), by=1)
span.grid <- neigh.grid/n
# set the grid of nearest neighbors search
neigh.grid <- seq(1, ceiling(n/2), by=1)
span.grid <- neigh.grid/n
span.grid
# set the grid of nearest neighbors search
neigh.grid <- seq(1, ceiling(n/2), by=1)
span.grid <- neigh.grid/n
library(pbapply)
library(parallel)
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE.knn", "kfolds"))
RMSE_wrapper <- function(curr.bws){find.RMSE.knn(curr.bws, n_fold, kfolds)}
all_RMSE <- pbsapply(neigh.grid, RMSE_wrapper, cl=cl)
source('quantile_kfold.R')
n_fold <- 5
set.seed(1)
data.fr <- data.frame(flow.norm=flow.norm, scores.pc1 = scores.pc1)
kfolds <- quantile_kfold(n_fold, data.fr, 'scores.pc1')
# function to find RMSE for a certain bandwidth
find.RMSE.knn <- function(curr.bws, n_fold, kfolds){
require(np)
RMSE <- numeric(n_fold)
for(i in 1:n_fold){
curr_data <- kfolds$datasets[[i]]
curr_miss <- kfolds$folds[[i]]
mod.curr <- npreg(flow.norm ~ scores.pc1, bwtype='adaptive_nn', ckertype = 'gaussian', bws=curr.bws, data = curr_data)
RMSE[i] <- sqrt(mean((predict(mod.curr, newdata=curr_miss) - curr_miss$flow.norm)^2))
}
return(mean(RMSE))
}
# set the grid of nearest neighbors search
neigh.grid <- seq(1, ceiling(n/2), by=1)
span.grid <- neigh.grid/n
library(pbapply)
library(parallel)
cl <- makeCluster(detectCores())
clusterExport(cl, varlist = list("n_fold", "find.RMSE.knn", "kfolds"))
RMSE_wrapper <- function(curr.bws){find.RMSE.knn(curr.bws, n_fold, kfolds)}
all_RMSE <- pbsapply(neigh.grid, RMSE_wrapper, cl=cl)
opt.neigh <- neigh.grid[which.min(all_RMSE)]
opt.neigh
opt.span <- opt.neigh/n
opt.span
min(all_RMSE)
x11()
plot(span.grid, all_RMSE, type ='l', lwd='2', main='Root MSE vs bandwidth')
abline(v=opt.span, col='red', lwd=2)
x11()
plot(span.grid, all_RMSE, type ='l', lwd='2', main='Root MSE vs span')
abline(v=opt.span, col='red', lwd=2)
mod.knn.opt <- npreg(flow.norm ~ scores.pc1, ckertype = 'gaussian', bws=opt.bws, bwtype='adaptive_nn')
summary(mod.knn)
xx <- seq(min(scores.pc1), max(scores.pc1), length.out = 1000)
preds <- predict(mod.knn.opt, newdata = data.frame(scores.pc1 = xx), se.fit=T)
x11()
plot(scores.pc1, flow.norm, main = 'Gaussian kernel regression')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
# RMSE
sqrt(mod.knn.opt$MSE)
mod.knn.opt <- npreg(flow.norm ~ scores.pc1, ckertype = 'gaussian', bws=opt.neigh, bwtype='adaptive_nn')
summary(mod.knn)
xx <- seq(min(scores.pc1), max(scores.pc1), length.out = 1000)
preds <- predict(mod.knn.opt, newdata = data.frame(scores.pc1 = xx), se.fit=T)
x11()
plot(scores.pc1, flow.norm, main = 'Gaussian kernel regression')
lines(xx, preds$fit, col='red', lwd=2)
matlines(xx, cbind(preds$fit - 2*preds$se.fit , preds$fit + 2*preds$se.fit ),
lty = 2, col = 'red', lwd=2)
# RMSE
sqrt(mod.knn.opt$MSE)
